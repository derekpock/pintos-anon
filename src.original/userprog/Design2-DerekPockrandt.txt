		           +--------------------------+
				   |         CIS 520          |
		           | PROJECT 2: USER PROGRAMS |
		           |     DESIGN DOCUMENT      |
		           +--------------------------+

---- GROUP ----

>> Fill in the names of your group members.

Derek Pockrandt
Benjamin Miller

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

I struggled on this assignment basically on my own. I spent a good 20 hours the
final weekend putting it together because my teammate did not assist me or
put forward effort into the project until 3 hours before it was due.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

I referenced some C documentation online, specifically how the memset code works
and when to use it. I also researched quite a bit about the layout of the
arguments on the stack to get better detail on positioning.

https://www.geeksforgeeks.org/memset-c-example/

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

No structs, struct members, variables, or enumerations were added or modified.

static void start_process (void *file_name_)
	Primary location of file name splitting and argument pushing. Almost
	entirely worked within this file.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

	At the beginning of the start process function, the file name is split 
	into multiple tokens, separated by spaces. This is how we got the argv
	list of arguments.
	
	After the load is called, we have access to the stack pointer esp. We then
	go into pushing items onto the stack. Here's a breif description of what
	happens:
	
	Allocate an array to keep a list of addresses for the argv pushes.
	Push each argument from (count - 1) to 0 onto the stack. This is done in
	reverse order, which is the necessary order when pushing. As these are
	pushed to the stack, the stack location is saved in the addresses array.
	
	Fix any byte offset issues with the esp. This ensured that the rest 
	of our pushes are done around byte sizes, which fixes a few particular bugs.
	
	Push the addresses onto the stack, including address at "count", which is 0.
	This is the ending element, showing the end of the array. Pushes addresses
	from count to 0, in reverse order, as needed.
	
	Pushes the address of the first argv element (or the address of argv itself).
	
	Pushes the number of elements (count, or argc).
	
	Pushes a fake return address (0).
	
	Free's memory used by the addresses, and arguments.
	
	We arranged the elements in order by pushing them in reverse.
	We were not sure how to avoid overflowing the stack page. Because of the
	pintos command line limit, this was difficult to test. We tried a few
	soltuions to this problem, but it ended up breaking other parts of the code.
	As for now, there is no set limit on this, unfortunately. Character strings
	could be very long, and I'm not exactly sure how to correctly map raw
	values of the stack pointer to bytes or kilobytes of memory.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

	This is done to allow greater control and use the save tokens in multiple
	threads, if necessary. It also allows for better memory management. With
	such a small space, memory must be saved where possible, so its better to
	setup a system that makes the caller create the variable outside of the
	call. Pintos wouldn't know when to release the save variable in strtok(),
	but the user knows when exactly its necessary with strtok_r().

>> A4: In Pintos, the kernel separates commands into an executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

	This allows for higher end manipulation of the arguments within the upper
	levels. Say I have one call, to a program that calls another program with
	just some of the variables. With the pintos approach, I need to manually,
	outside the kernel, separate the arguments and rejoin them before adding 
	them to the next command. This is slower, and can cause odd bugs.
	The unix style is also better because this is less memory intensive for the
	kernel. If possible memory should be reserved, and restricted, to who is
	using it. If a very long argument call was made to a kernel in Pintos, the
	kernel needs to catch it and deal with it. Otherwise, in Unix, the shell
	will either catch the error earlier, or end with an OOM exception sooner.
	This also allows the user to debug theses issues easier. If an error occurs 
	in the arguments, but they are only passed to the kernel, then errors from
	the kernel can crash the entire program, instead of allowing and exception
	to handle the crash.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct list semaWait_list;
	Maps a pid to a semaphore. If a thread waits on process 5, then it will
	wait on the semaphore maped from int 5. On exiting, process 5 will up
	this semaphore and allow the initial thread to release from the wait.
struct list threadExit_list;
	Maps pid to int. Once a process starts, its pid is put in here with -1 as
	the exit code, until it ends with a better code. Once ending the new code
	is put in place, and this is where other threads retireve the exit code.

struct semaMap {	Map used in semaWait list
  struct semaphore sema;	//Semaphore threads wait on until ended
  int key;	//PID of the process that threads are waiting on. The key.
  struct list_elem elem;	//List element so it can exist in a list.
};

struct intMap {	Map used in the threadExit an many other lists.
  int value;	//Value often a PID or an exit code, of the map.
  int key;		//Key, often a PID, of the map.
  struct list_elem elem;	//For lists.
};

//Allocates memory and creates a new sema map item.
struct semaMap* createSemaMap(unsigned);

//Allocates memory and creates a new int map item.
struct intMap* createIntMap(void);

...within thread struct...	
    struct file* executedFile;
    //Keeps hold of the file used to execute the thread, if it exists.
    //When exiting, if not null, will unlock writes to this file.

struct list parentChildList;
	List of intMaps linking parents to their children processes.
struct list parentWaitingOnChildrenList;
	List of intMaps linking parents to children they are waiting on.
struct lock fileIOLock;
	Lock used to manage file IO and prevent asynch chaos when writing.


struct fileItem {	A wrapper for the current file item, used to manage one process read/write ability to a file.
  int fd;	//FD given to this file
  int pidOwner;	//Owner of the file
  char* name;	//Name of the file, this is a copy
  unsigned position;	//Position in the file, modified by read, write, and seek calls
  struct file* fsFile;	//The file being used. Not unique to this fileItem. Given to other processes as well.
  struct list_elem elem;	//For lists.
};

static struct fileItem* createNewFileItem(int fd, int pid, const char* name, struct file* fsFile);
	Create a new fileItem struct, allocating memory and setting up the values as necessary.
static struct list openFilesList;
	List of fileItems, open files. Multiple struct file may exist in this list, if more than once process is openning and working with a file.
static int nextFd;
	Fd assigner incremented, starting at 2, for each file being openned.
static bool verifyPointer(void *pointer);
	Handy function used to verify the pointer passed to it. Kills the process
	if the pointer is invalid.
	
static void closeFile(struct fileItem* fileClose);
	Used to close a file. Checks if all other fileItem's contain a copy of the struct
	file used in this fileItem (fileClose). If so, actually closes the file in
	the file system. Otherwise, keeps it open for the other processes to use the file.
void closeFilesFromPid(int pid);
	Searches and closes all files that pid opened. Calls closeFile often.

static void syscall_handler (struct intr_frame *f UNUSED);
	Heavily modified to add system call functionalities.
int process_wait (tid_t child_tid)
	Modified to appropriately allow a parent to wait on a child. Returns -1 if the
	call is wrong.
void process_exit (void)
	Modified to provide the exit code as necessary and wake up parents that may
	be sleeping.


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

	File descriptors are unique to the entire OS. With the struct fileItem setup,
	each fileItem has a unique FD. However, the name of the file, the struct file
	recieved in the fileItem, are not unique. The pid-owner <-> name IS unique,
	so process can only open a file once, not multiple times.
	The FD is simply incremented and assigned, much like the TID given to threads.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

	All user data pointers and even the stack pointer is checked for validity
	often before being dereferenced or used. The code for reading and writing to
	files is fairly straight forward, utilizing the fileItem struct wrapper for
	the already provided filesystem IO.
	The checks done to pointers are simply check if null, check if in bound, and
	check if the page table exists in the page frame. If any of these fail, the 
	pointer is invalid.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

	If the full page is copied, there could technically be 8 thousand calls
	to page data. If they passed 4000 characters, that's 4000 character calls
	and 4000 stack pointer calls to verify. This can definitely be improved.
	We could check the beginning of the stack, and go to the end of the stack,
	only keeping an eye on the stack pointer, since we know all data within the
	bounds is relevant. This could be improved to 1 call, technically. As long
	as it doesn't leave the page limit.
	The lease inspections for 4k data would be 2, if there existed a 4k data
	structure. Once for the data, again for the stack pointer.
	2 bytes is already fairly optimal. It would call 2 or 4 checks, depending
	on the data. 1 or 2 for the data itself, 1 or 2 for the stack pointer.
	That could be improved to one as well.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.
	
	When a thread starts, it adds a map item to a list, semaphore initialized
	 to zero. When a parent wants to wait on this new thread, it simply finds
	  this semaphore, after going through some validation, waits on it by
	   lowering it. In any case, whether terminated or simply exited correctly, 
	   the thread that was being waited on will raise its semaphore, allowing 
	   the waiting parents to grab the semaphore, and realize that the thread 
	   is finished. Before the semaphore is raised by the thread, it assigns 
	   it's exit code to another list, a parent can retrieve from as necessary.
	    There are a number of checks that the parents must go through to ensure 
	    that they can listen and wait for the thread to end.
	
>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

	(hand hurts, this is speech to text, sorry for grammar)
	  putting all of the code that is used to verify a pointer and closeout a
	   process into one function makes this code bit slimmer. especially if the
	    function  name is very simple and short, this can ensure the actual 
	    Integrity of the code can easily be understood. to ensure that all the 
	    resources are released , simply do not collect any resources until all
	     data is verified. in the code that I wrote I simply ensure that all the 
	     arguments I receive are legitimate verified before I pass them to 
	     another sub handler or handle them differently. throughout this argument
	      collection, the verification function is called several times to
	       ensure each pointer is legitimate. If let's say, an argument passes
	        to pointers, and the first one is valid, but the second one is not.
	         the first one will be validated and correct, second one will fail
	          validation and the process will be ended.  In no situation will a 
	          lock be gathered or a semaphore lowers before all data is verified

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

	This was overlooked due to the lack of time and work on the project. However,
	if this was to be implemented, I would add another list semaphore in thread
	that will lock when the process start is called, and the parent will be
	waiting on this semaphore. Once the process finishes, it would raise the
	semaphore, and set a success value in the semaphore (lets say, raise semaphore
	twice for failure, then the parent checks the values of the semaphore, or
	even just a side boolean value of sucess or not). Once finished, the parent
	would then continue and finish the last bit of the process start, and either
	retrieve the tid, or the -1 for failure.


>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

	The only interaction between P and C is a semaphore that exists after C is
	released. Because P could wait on C forever after C has exited, the
	semaphore, the only resource, would be removed only after P would be
	destroyed, or after P waits on C. Our code is not perfect, but manages many
	cases.
	
	If P calls C before C exits, then P waits on the semaphore while C continues.
	C will simple raise semaphore then P continues.
	
	If P calls C after C exits, the semaphore is already raised by C, so P
	will continue right away.
	
	If P terminates before C, then the semaphore is removed, and C won't raise
	any semaphore when exiting.
	
	If C exits, P has to exit before the semaphore is removed, or call wait. Only
	then is the resource removed.
	
	Apart from these, there are no special cases. Synch worked with semaphores.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

	This was implemented for ease of use, readability, and reduced to none 
	page-faults. While this is less efficient, it is easier to see and you
	can handle some special cases if wanted by using checks before dereferencing.
	We implemented the first of two suggested ways of handling it also primarily
	because we did not understand how to implement the other way.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

	Our file descriptors do use a bit more data than otherwise. It might also
	be a bit less efficient since we have to check the whole list to get to
	our descriptor each time. The list functionality is quick, but can be slow
	if we have a lot of files. However, it improves readability and consistency
	between various options to have all the information in a "wrapper" above the
	struct file provided by the file system. We also can take advantage of
	checking for open files before calling another open, or closing all files
	from a PID by just seaching for the PID! Benefits and cons to both options.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

	We did not change this. All threads and processes use PID and TID at the
	same time. We know that TID is unique, and PID in our case only comes from
	TID, so this is a simple and sure-fired way to ensure it works well. I
	would change in the future, that the TID and PID to refer to the same 
	variable typedef, instead of two separate, which could get confusing to
	realize any difference.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

Hard, but not too hard. It took a very long time, especially since my teammate
didn't really help at all. It took quite a bit to understand the syscalls.
Having a better skeleton would be nice, even if it was just an if statement
showing the implementation of the HALT. It took forever for me to realize how
to PUSH and PULL from the stack! I need some examples please! Provide an example
of how to PUSH arguments and PULL arguments from system calls. Would have made
the struggle of starting much less.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

Yes, I learned more about the stack.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

Guide them on pushing and pulling from the stack. Everything else was just
research and smarts oriented. I spent a lot more time just figuring out how
to push to the stack instead of figuring out how to push to it "correctly".
If that makes sense. I spent more time trying to figure out the specifics
and querkiness of Pintos itself instead of the underlying concepts you were
trying to teach through this assignment.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

Teammate did little to no work. This will be reflected in the team member eval.
